---
title: "Results: Plots and Tables"
output: html_document
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
knit: (function(inputFile, encoding) { 
    out_dir <- '../../docs/';
    rmarkdown::render(inputFile,
                      encoding=encoding, 
                      output_file=file.path(dirname(inputFile), out_dir, 'problem-statistics.html')) })
---

```{r setup, include=FALSE}
here::i_am("code/instances/problem-statistics.Rmd")  # specify relative path given project
# remotes::install_github("relund/gMOIP")
# library(gMOIP)
library(DT)
library(tidyverse)
# library(knitr)
# library(rgl)
# rgl::setupKnitr()
# options(rgl.useNULL=TRUE)
# rgl::par3d("family" = "serif")
knitr::opts_chunk$set(
  echo = FALSE,
  message=FALSE, include = TRUE, warning = FALSE,
  out.width = "99%", fig.width = 8, fig.align = "center", fig.asp = 0.8
)
```

This report contains different plots that may be relevant when visualizing the results.

## $|Y_N|$ given |Y_N^s|

Given a problem consisting of a set of subproblems with $Y_N^s$ given for each subproblem $s$, we use a filtering algorithm to find $Y_N$. Note that

  * The hypercube $|Y_N|$ is placed in is approx. $[0, 10000m]^p$, since each subproblem $Y_N^s \subset [0, 10000]^p$. That is, more subproblems create a lager hypercube with solutions and the volume (number of integer points) grows exponentially in $p$. 
  * Given $|Y_N|$, we can find the hypercube as $$[l_1, u_1] \times \cdots \times [l_p, u_p],$$ where $l_i = \min_{y \in |Y_N|}(y_i)$ and $u_i = \max_{y \in |Y_N|}(y_i)$.
  * The number of integer points in the hypercube is $$\prod_{i = 1}^p (u_i - l_i + 1)$$





and afterwards classify the nondominated points into, extreme, supported non-extreme and unsupported.

```{r}
raw <- read_csv(here::here("code/instances/stat-prob.csv"))
dat <- raw %>% 
  mutate(method = str_extract(path, "^.*-(.*)-.*$", group = 1)) %>% 
  mutate(method = map_chr(method, function (x) {
  x <- str_split_1(x, "")
  x <- unique(x)
  str_c(x, collapse = "")
  })) %>% 
  rowwise() %>% 
  mutate(aveWidth = mean(c_across(starts_with("width")), na.rm = T),
         points_hypercube = if_else(is.nan(aveWidth), NA, prod(1 + c_across(starts_with("width")), na.rm = T)),
         spAveCard = mean(c_across(starts_with("spCard")), na.rm = T)) %>% 
  ungroup() %>% 
  mutate(
         pctSup = supported/card,
         m = as.numeric(str_extract(path, "^.*-(.*)_.*$", group = 1))) 
# stat for subproblems
for (s in 1:max(dat$m)) {
  dat[, str_c("spPctSup", s)] <- dat[, str_c("spSupported", s)] / dat[, str_c("spCard", s)]
} 
dat <- dat %>% 
  rowwise() %>% 
  mutate(
    spAvePctSup = mean(c_across(starts_with("spPctSup")), na.rm = T),
    ubCard = prod(c_across(starts_with("spCard")), na.rm = T)
  ) %>% 
  ungroup()
DT::datatable(dat)
```


```{r}
# dat %>% mutate(cst = hypervolume/(m * 10000)^p) %>% ungroup() %>% summarise(val = mean(cst, na.rm = T))
```


Overview over subproblems not solved yet

```{r}
dat %>% 
  group_by(p, m, method, spAveCard) %>% 
  summarise(instances = n(), card = mean(card), pctSup = mean(pctSup)) %>% 
  filter(instances < 5)
```


Let the width for an objective denote the difference between the max and min value. Note subproblems are generated using a width of approx. 10000.   

```{r}
dat %>% 
  ggplot(aes(x = m, y = aveWidth, color = method)) +
  geom_point() + 
  geom_smooth(se = F) +
  facet_wrap(vars(p)) +
  labs(title = "Average objective width (should be approx. m * 10000)",
       y = "Average objective width",
       x = "Number of subproblems (m)",
       color = "Method(s) used to generate subproblems") +
  theme(legend.position = "bottom")
```

```{r}
dat %>% 
  ggplot(aes(y = card / ubCard, x = method)) +
  geom_boxplot() +
  facet_grid(m ~ p, margins = T) 
  # labs(title = "Number of nondominated points given subproblem cardinality",
  #      y = "Cardinality Yn",
  #      x = "Average subproblem cardinality",
  #      color = "Method(s) used to generate subproblems") +
  # theme(legend.position = "bottom")

```

```{r}
dat %>% 
  ggplot(aes(x = spAveCard, y = card, color = method)) +
  geom_point() + 
  geom_smooth(se = F) +
  facet_grid(m ~ p, scales = "free", margins = T) + 
  labs(title = "Number of nondominated points given subproblem cardinality",
       y = "Cardinality Yn",
       x = "Average subproblem cardinality",
       color = "Method(s) used to generate subproblems") +
  theme(legend.position = "bottom")

```

```{r}
dat %>% 
  ggplot(aes(x = method, y = card)) +
  geom_boxplot() + 
  facet_wrap(vars(p), scales = "free") + 
  labs(title = "Number of nondominated points given method",
       y = "Cardinality Yn",
       x = "Method(s) used to generate subproblems") +
  theme(legend.position = "bottom")
```


```{r}
dat %>% 
  ggplot(aes(x = p, y = card/(10000^m), color = method)) +
  geom_point() + 
  geom_smooth(se = F) +
  # facet_wrap(vars(p), scales = "free") + 
  # labs(title = "Number of nondominated points",
  #      y = "Cardinality Yn",
  #      x = "Average subproblem size",
  #      color = "Method(s) used to generate subproblems") +
  theme(legend.position = "bottom")
```

```{r}
dat %>% 
  ggplot(aes(x = method, y = pctSup)) +
  geom_boxplot() + 
  # geom_smooth(se = F) +
  # facet_wrap(vars(p)) +
  # labs(title = "Average objective width",
  #      y = "Average objective width",
  #      x = "Number of subproblems",
  #      color = "Method(s) used to generate subproblems") +
  theme(legend.position = "bottom")
```

```{r}
dat %>% 
  ggplot(aes(x = spAvePctSup, y = pctSup, color = method)) +
  geom_point() + 
  geom_smooth(se = F) +
  facet_wrap(vars(p)) +
  # labs(title = "Average objective width",
  #      y = "Average objective width",
  #      x = "Number of subproblems",
  #      color = "Method(s) used to generate subproblems") +
  theme(legend.position = "bottom")
```


```{r}
dat %>% 
  ggplot(aes(x = , y = pctSup)) +
  geom_boxplot() + 
  # geom_smooth(se = F) +
  # facet_wrap(vars(p)) +
  # labs(title = "Average objective width",
  #      y = "Average objective width",
  #      x = "Number of subproblems",
  #      color = "Method(s) used to generate subproblems") +
  theme(legend.position = "bottom")
```
