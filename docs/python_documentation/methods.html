<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>methods API documentation</title>
<meta name="description" content="methods/algorithms for filtering out nondominated points
specifically for a single set (Non minkowski sum problem) â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>methods</code></h1>
</header>
<section id="section-intro">
<p>methods/algorithms for filtering out nondominated points
specifically for a single set (Non minkowski sum problem)</p>
<p>IMPLEMENTED methods:
basic_filter(Y) -&gt; Yn
naive_filter(Y) -&gt; Yn
lex_sort(Y) -&gt; sorted(Y)
unidirectional_filter(Y) -&gt; Yn</p>
<pre><code>MS_sum(Y_list) -&gt; Y_ms, Minkowski sum of sets in Y_list
MS_naive_filter(Y_list) -&gt; N(Y_ms)
MS_sequential_filter(Y_list) -&gt; N(Y_ms)
MS_doubling_filter(Y_list) -&gt; N(Y_ms)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
methods/algorithms for filtering out nondominated points
specifically for a single set (Non minkowski sum problem)

IMPLEMENTED methods:
    basic_filter(Y) -&gt; Yn
    naive_filter(Y) -&gt; Yn
    lex_sort(Y) -&gt; sorted(Y)
    unidirectional_filter(Y) -&gt; Yn

    MS_sum(Y_list) -&gt; Y_ms, Minkowski sum of sets in Y_list
    MS_naive_filter(Y_list) -&gt; N(Y_ms)
    MS_sequential_filter(Y_list) -&gt; N(Y_ms)
    MS_doubling_filter(Y_list) -&gt; N(Y_ms)
&#34;&#34;&#34;
from classes import Point, PointList, LinkedList, Node, KD_Node, KD_tree
import numpy as np
import os
import subprocess # for running c execute
from collections import deque # for fast leftappend
from operator import itemgetter # for lexsort function to define keys
import math
import uuid
import time


def basic_filter(Y:PointList):
    &#34;&#34;&#34;
    input: PointList
    output: PointList with all nondominated points removed

    ALG:
        For each point y, check if any other point y2 dominates y: if no, add y to Yn
    &#34;&#34;&#34;
    Yn = []

    for y in Y:
        for y2 in Y:
            if y2 &lt; y:
               break 
        else:
            Yn.append(y)

    return(PointList(Yn))


def naive_filter(Y:PointList, MCtF = False) -&gt; PointList:
    &#34;&#34;&#34;
    input: PointList
    output: PointList with all nondominated points removed

    ALG:
        For each point y, check if any other point y2 dominates y: if no, add y to Yn
    &#34;&#34;&#34;
    Yn = deque()

    for i, y in enumerate(Y):
        dominated_indices_y = set()
        for j, y2 in enumerate(Yn):
            if y2 &lt;= y:
                break # discard y
            if y2 &gt; y:
                dominated_indices_y.add(j) # record dominance
        else:
            # remove dominated points
            Yn = deque((y_ for j_, y_ in enumerate(Yn) if j_ not in dominated_indices_y))
            # add nondominated candidate
            if MCtF and dominated_indices_y:
                Yn.appendleft(y)
            else:
                Yn.append(y)

    # Y.points = Yn
    return(PointList(Yn))


def two_phase_filter(Y: PointList) -&gt; PointList:
    &#34;&#34;&#34; Two phase filter from Chen2012 for filtering a list of points

    Args:
        Y (PointList): Yn (PointList) set of nondominated points 

    Returns: PointList with all nondominated points removed
    &#34;&#34;&#34;
    
    Y = lex_sort(Y)
    
    Yn = PointList(())
    Yn.dim = Y.dim
    Yn.points = list(Yn.points)
    # phase 1
    for i, y in enumerate(Y):
        if not Yn.weakly_dominates_point(y):
            Yn.points.append(y)
    # print(f&#34;Phase 1 result: {Yn=}&#34;)
    # phase 2
    Yn_new = PointList()
    Yn_new.dim = Yn.dim
    Yn_new.points = list(Yn_new.points)
    for i in range(len(Yn)):
        y = Yn[-i + 1]
        if not Yn_new.weakly_dominates_point(y):
            Yn_new.points.append(y)
    return Yn_new       


def KD_filter(Y: PointList):
    &#34;&#34;&#34; Kd-tree filtering algorithm from Chen2012

    Args:
        Y (PointList)

    Returns:
        Yn (PointList) set of nondominated points 

    Returns: PointList with all nondominated points removed

    &#34;&#34;&#34;
    Y = lex_sort(Y) # sort input list
    R = []
    for i, y in enumerate(Y):
        if i == 0:
            r = KD_Node(Y[0], 0)
            r.UB = r.y
            r.LB = r.y
            k = 0
            R.append(y)
            continue

        if not KD_tree.dominates_point(r, y):
            # print(f&#34;{y=}&#34;)
            KD_tree.insert(r,0, y)
            R.append(y)
            k += 1

    r = None
    Yn = []
    for i, y in enumerate(reversed(R)):
        if i == 0:
            r = KD_Node(y, 0)
            r.UB = r.y
            r.LB = r.y
            Yn.append(y)
            continue
        
        if not KD_tree.dominates_point(r, y):
            KD_tree.insert(r,0, y)
            Yn.append(y)

    Yn = PointList(Yn)

    return Yn


def lex_sort(Y: PointList):
    &#34;&#34;&#34;
    input: PointList
    output: lexicographically sorted PointList Y

    source https://stackoverflow.com/questions/38277143/sort-2d-numpy-array-lexicographically
    &#34;&#34;&#34;
    Y.points = sorted(Y.points, key=itemgetter(*range(Y.dim)))

    for i in range(len(Y.points)-1): # simple but not exhaustive correctness check
        assert not Y[i] &gt; Y[i+1], f&#34;{Y[i]=},{Y[i+1]=} &#34;

    return PointList(Y.points)


def unidirectional_filter(Y: PointList, duplicates_allowed = False) -&gt; PointList:
    &#34;&#34;&#34;
    input: PointList, bool - allowed_duplicates
    output: PointList with all nondominated points removed
    &#34;&#34;&#34;


    Y = lex_sort(Y)

    # p = 2
    assert Y[0].val.shape[0] &lt;= 2, &#34;dim p &gt; 2 NOT IMPLEMENTED&#34;
    Yn = []
    
    if duplicates_allowed:
        for y in Y:
            if Yn == [] or not Yn[-1] &lt; y:
                Yn.append(y)
                # assert not PointList(Yn).dominates_point(y), f&#34;{Yn=}, {y=}&#34;
    
    else: # if duplicates not allowed
        for y in Y:
            if Yn == [] or not Yn[-1] &lt;= y:
                Yn.append(y)
    return(PointList(Yn))

    # p &gt; 2 NOT IMPLEMENTED



def call_c_nondomDC(call_id:str, max_time=None, logger=None):
    # current_d = os.getcwd()
    # move to c folder and execute
    # os.chdir(&#39;/Users/au618299/Desktop/cythonTest/nondom/&#39;)
    # subprocess.call([&#39;./nondom&#39;,call_id])
    # return to initial directory
    # os.chdir(current_d)
    # subprocess.call([&#39;/Users/au618299/Desktop/cythonTest/nondom/./nondom&#39;,call_id])
    assert &#39;nondom&#39; in os.listdir()
    # subprocess.call([&#39;./nondom&#39;,call_id])
    p = subprocess.Popen([&#39;./nondom&#39;,call_id])

    try:
        if max_time:
            p.wait(timeout=max_time*60)
        else:
            p.wait()
    except subprocess.TimeoutExpired:
        print(f&#34;Process timed out after {max_time} seconds&#34;)
        p.kill()
        print(&#34;Process killed due to timeout&#34;)
        if logger:
            logger.warning(&#34;Process timed out after {max_time} seconds {call_id=}&#34;)



def call_c_ND_pointsSum2(call_id:str, max_time=None,max_gb=None, logger=None, verbose = False):
    assert &#39;ND_pointsSum2&#39; in os.listdir()

    # print(f&#34;calling subprocess &#34;)
    if max_gb:
        if verbose:
            p = subprocess.Popen([&#39;./ND_pointsSum2&#39;,call_id,str(max_gb)])
        else:
            p = subprocess.Popen([&#39;./ND_pointsSum2&#39;,call_id,str(max_gb)], stdout=subprocess.DEVNULL)
    else:
        if verbose:
            p = subprocess.Popen([&#39;./ND_pointsSum2&#39;,call_id])
        else:
            p = subprocess.Popen([&#39;./ND_pointsSum2&#39;,call_id], stdout=subprocess.DEVNULL)

    
    try:
        if max_time:
            p.wait(timeout=max_time*60)
        else:
            p.wait()
    except subprocess.TimeoutExpired:
        print(f&#34;Process timed out after {max_time} seconds&#34;)
        p.kill()
        print(&#34;Process killed due to timeout&#34;)
        if logger:
            logger.warning(&#34;Process timed out after {max_time} seconds {call_id=}&#34;)
            logger.info(f&#34;{p.returncode=}&#34;)
        print(f&#34;{p.returncode=}&#34;)
    # print(f&#34;subprocess complete &#34;)


def nondomDC_wrapper(Y : PointList):
    # A python wrapper for the c implementation of NonDomDC [Bruno Lang]
    call_id = str(uuid.uuid4())
    # out_file = fr&#34;/Users/au618299/Desktop/cythonTest/nondom/temp/pointsIn-{call_id}&#34; # c script directory
    out_file = fr&#34;temp/pointsIn-{call_id}&#34; # c script directory
    Y.save_raw(out_file)
    assert os.path.exists(out_file), f&#34;{out_file=}&#34;

    try:
        out_str = call_c_nondomDC(call_id)
    finally:
        os.remove(out_file)
    # in_file = filepath = fr&#34;/Users/au618299/Desktop/cythonTest/nondom/temp/pointsOut-{call_id}&#34; # c script directory
    in_file = filepath = fr&#34;temp/pointsOut-{call_id}&#34; # c script directory
    assert os.path.exists(in_file), f&#34;{in_file,out_str=}&#34;
    Yn = PointList.from_raw(in_file)
    # print(f&#34;{in_file=}&#34;)
    try:
        Yn = PointList.from_raw(in_file)
    except FileNotFoundError:
        print(f&#34;File not found&#34;)
        print(f&#34;{in_file=}&#34;)
        return None

    if True: # clear temp folder
        # os.remove(out_file)
        os.remove(in_file)
    return Yn.removed_duplicates()


def ND_pointsSum2_wrapper(A : PointList, B : PointList) -&gt; PointList:
    # A python wrapper for the c implementation of ND_pointsSum2 [Bruno Lang]
    call_id = str(uuid.uuid4())
    # out_file = fr&#34;/Users/au618299/Desktop/cythonTest/nondom/temp/pointsIn-{call_id}&#34; # c script directory
    out_fileA = fr&#34;temp/pointsInA-{call_id}&#34; # c script directory
    out_fileB = fr&#34;temp/pointsInB-{call_id}&#34; # c script directory
    A.save_raw(out_fileA)
    B.save_raw(out_fileB)
    try:
        call_c_ND_pointsSum2(call_id)
    finally:
        os.remove(out_fileA)
        os.remove(out_fileB)


    in_file = filepath = fr&#34;temp/pointsOut-{call_id}&#34; # c script directory
    try:
        Yn = PointList.from_raw(in_file)
    except FileNotFoundError:
        return None

    if True: # clear temp folder
        os.remove(in_file)
    return Yn.removed_duplicates()


def N(Y = PointList, **kwargs):
    &#34;&#34;&#34; &#39;best&#39; implemented nondominance filter &#34;&#34;&#34;
    if Y[0].dim &lt;= 2:
        return unidirectional_filter(Y, *kwargs)
    else:
        return nondomDC_wrapper(Y)


    # elif len(Y) &lt; 1024*2:
        # return KD_filter(Y)
    # else:
        # return nondomDC_wrapper(Y)
        # return naive_filter(Y, MCtF = True)
        # return two_phase_filter(Y)

def MS_sum(Y_list = list[PointList], operator = &#34;+&#34;) -&gt; PointList:
    &#34;&#34;&#34;
    input: list of PointList
    output: Minkowski sum of sets
    &#34;&#34;&#34;
    assert operator in (&#34;+&#34;,&#34;-&#34;,&#34;*&#34;)

    Y_ms = Y_list[0]
    for s in range(1, len(Y_list)):
        Y_ms_new = []
        Y_s = Y_list[s]
        for y_ms in Y_ms:
            for y_s in Y_s:
                if operator == &#34;+&#34;:
                    Y_ms_new.append(y_ms+y_s)
                if operator == &#34;-&#34;:
                    Y_ms_new.append(y_ms-y_s)
                if operator == &#34;*&#34;:
                    Y_ms_new.append(y_ms*y_s)
        Y_ms = Y_ms_new

    return PointList(Y_ms)



def MS_naive_filter(Y_list = list[PointList]) -&gt; PointList:
    &#34;&#34;&#34;
    input: list of PointList
    output: nondominated points of Minkowski sum of sets Y_list
    &#34;&#34;&#34;
    Y = MS_sum(Y_list)
    Yn = N(Y)

    return PointList(Yn)
 

def MS_sequential_filter(Y_list = list[PointList], N = N) -&gt; PointList:
    &#34;&#34;&#34;
    input: list of PointList
    output: nondominated points of Minkowski sum of sets Y_list
    &#34;&#34;&#34;
    Y_ms = N(Y_list[0])

    for s in range(1, len(Y_list)):
        # print(f&#34;{s=}&#34;)
        # print(f&#34;{len(Y_ms)=}&#34;)
        # Y_ms = N(Y_ms + N(Y_list[s]))
        Y_ms = ND_pointsSum2_wrapper(Y_ms, N(Y_list[s]))
        Y_ms = Y_ms.removed_duplicates()
        # assert Y_ms == N(Y_ms), f&#34;{len(Y_ms),len(N(Y_ms)),len(Y_ms.removed_duplicates())=}&#34;
        if Y_ms is None:
            return None

    return PointList(Y_ms)


def MS_doubling_filter(Y_list = list[PointList], MS_filter_alg = MS_sequential_filter) -&gt; PointList:
    &#34;&#34;&#34;
    input: list of PointList
    output: nondominated points of Minkowski sum of sets Y_list
    &#34;&#34;&#34;

    s = len(Y_list)
    S = Y_list
    while s &gt; 1:
        S_new = []
        for k in range(math.floor(s/2)):
            S_new.append(MS_filter_alg((S[2*k], S[2*k+1])))
        if s % 2 != 0:
            S_new.append(S[-1])
        s = math.ceil(s/2)
        S = S_new
    return S[0]
        
   



def lex_sort_linked(Y: PointList):
    &#34;&#34;&#34;function for sorting p = 2$&#34;&#34;&#34;
    assert Y.dim &lt;= 2, &#34;dim p &gt; 2 NOT IMPLEMENTED&#34;
 
    llist = LinkedList()
    llist.add_first(Node(Y[0]))
    llist.head.prev = None

    for y_current in Y[1:]:
        for N in llist:
            if y_current.val[0] &gt;= N.data.val[0]:
                continue
            # traverse linked list until y lex dominated the node N
            if y_current.lex_le(N.data):
                new_node = Node(y_current)
                # add before N
                llist.add_before(N.data, new_node)

                # remove N.data and all dominated children
                first_nondom = N
                # while first_nondom != None and y_current &lt; first_nondom.data:
                    # first_nondom = first_nondom.next
                    # print(f&#34;removing {first_nondom}&#34;)
                new_node.next = first_nondom
                break
           #  elif N.data &lt; y_current:
           #      break
            prev = N
        else:
            if N.next == None:
                new_node = Node(y_current)
                N.next = new_node
    return PointList((N.data for N in llist.__iter__()))


def lex_filter(Y: PointList):
    &#34;&#34;&#34;function for filtering out dominated points using linked lists for p = 2$&#34;&#34;&#34;
    assert Y.dim &lt;= 2, &#34;dim p &gt; 2 NOT IMPLEMENTED&#34;
 
    llist = LinkedList()
    llist.add_first(Node(Y[0]))
    llist.head.prev = None

    for y_current in Y[1:]:
        for N in llist:
            if y_current.val[0] &gt;= N.data.val[0]:
                if y_current.val[1] &gt;= N.data.val[1]:
                    break
                else:
                    continue
            # traverse linked list until y lex dominated the node N
            if y_current.lex_le(N.data):
                new_node = Node(y_current)
                # add before N
                llist.add_before(N.data, new_node)

                # remove N.data and all dominated children
                first_nondom = N
                while first_nondom != None and y_current &lt; first_nondom.data:
                    first_nondom = first_nondom.next
                    # print(f&#34;removing {first_nondom}&#34;)
                new_node.next = first_nondom
                break
           #  elif N.data &lt; y_current:
           #      break
            prev = N
        else:
            if N.next == None:
                if not N.data &lt; y_current:
                    new_node = Node(y_current)
                    N.next = new_node
    return PointList((N.data for N in llist.__iter__()))


def induced_UB(Y: PointList, line=False, assumption = &#34;consecutive&#34;):
    &#34;&#34;&#34; Induced upper bound set from pointlist Y, points are assumed to be consecutive in Yn&#34;&#34;&#34;
    # arg assumption in [consecutive, supported, nonconsecutive]
    assert assumption in [&#34;consecutive&#34;, &#34;supported&#34;, &#34;nonconsecutive&#34;,&#34;localNadir&#34;]

    Y = N(Y)
    Y = lex_sort(Y)
    U = []
    seen = set() # for spotting duplicates
    if line:
        U.append(Y[0])
        for i in range(len(Y)-1):
                if assumption == &#34;consecutive&#34;:
                    u = Point((Y[i+1][0], Y[i][1]))
                elif assumption in {&#34;nonconsecutive&#34;, &#34;localNadir&#34;}:
                    u = Point((Y[i][0], Y[i+1][1]))
                if assumption != &#34;supported&#34;:
                    U.append(u)
                U.append(Y[i+1])
    else:
        for i in range(len(Y)-1):
            if Y[i+1] not in seen: # ignore duplicates
                seen.add(Y[i+1])
                u = Point((Y[i+1][0], Y[i][1]))
                U.append(u)
    if assumption == &#39;localNadir&#39;:
        U = PointList([Y[0]] + U + [Y[-1]])
        assert U.dim == 2
    else:
        U = PointList(U)
    return U
 



def find_generator_U(Y1:PointList, Y2:PointList) -&gt; PointList:
    &#34;&#34;&#34;
    input: two sets Y1, Y2, where Y1 contains (global) lex min solutions.
    output: A set of generator upper bound points Uc as PointList
    &#34;&#34;&#34;

    def get_i(points: PointList, q: Point):
        &#34;&#34;&#34;
        intervals: a PointList y1_1 &lt; y2_1 &lt; y3_1 ... 
        q: a Point
        returns the id i of PointList where yi_1 == q_1
        &#34;&#34;&#34;
        if points[0][0] == q[0]:
            return 0
        if points[-1][0] &lt;= q[0]:
            return -1 

        # assert that Q is sorted (consequence of Y2 sorted)
        for i, y in enumerate(points):
            if points[i][0] &lt;= q[0] and q[0] &lt; points[i+1][0]:
                return i

    Y1 = N(Y1)
    Y2 = N(Y2)

    Y = N(Y1+Y2)

    y_ul = Y1[0]
    y_lr = Y1[-1]

    u_current = y_ul
    Uc = [u_current]
    Q = PointList((u_current,)) + Y2

    while u_current != y_lr:
        #assert Q == PointList((u_current,)) + Y2
        # determine right movement
        Q_bar = [q for q in Q if Y[get_i(Y,q)][1] == q[1]]
        l1 = max([Y[get_i(Y,q)+1][0]-q[0] for q in Q_bar])

        # determine down movement
        Q = Point((l1,0)) + Q
        u_current = u_current + Point((l1, 0))
        l2 = min([q[1] - Y[get_i(Y,q)][1] for q in Q])

        # Update Q, u_current and Uc
        Q = Point((0,-l2)) + Q
        u_current = u_current + Point((0, -l2))
        Uc.append(u_current)

    return PointList(Uc)


def U_dominates_L(U: PointList, L:PointList):
    &#39;&#39;&#39;
    Checks if the lower bound L is dominated by the upper bound U
    input :
        U : list of non-dominated points as tuples
        L : list of supported points which make up the lower bound set
    &#39;&#39;&#39;
    assert all((L.dim == U.dim, L.dim == 2))
    # y = sorted(set(L)) # sort non-dominated points

    
    if L.is_complete: # Assume Yn = Ln, ie LB not defined by the convex hull
        return N(U) &lt; N(L)


    L = lex_sort(N(L))
    local_nadir_points = induced_UB(U)

    if len(L) == 1:
        return U.dominates_point(L[0])
    
    # Check that all extreme points of L are dominated
    for l in L:
        for u in U:
            if u &lt; l:
                break
        else: # finally, if loop terminates normally
            # print(f&#34;The LB point {l=} is not dominated by any point of U&#34;)
            return False

    # Check that all line segments of L are dominated
    for i in range(len(set(L)) - 1):
        # define linear function (line between l[i] and l[i+1])
        lin_fct = lambda x : L[i][1] + (L[i+1][1]-L[i][1])/(L[i+1][0]-L[i][0])*(x-L[i][0])
        for n in local_nadir_points:
            if L[i][0] &lt;= n[0] and n[0] &lt;= L[i+1][0]:
                if n[1] &gt; lin_fct(n[0]):
                    # print(f&#34;line between {L[i],L[i+1]} is not dominated by nadir-point {n}&#34;)
                    return False
                if math.isclose(n[1], lin_fct(n[0])):
                    return False
    # if loop ends, the node is not dominated by the upper bound set
    return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="methods.KD_filter"><code class="name flex">
<span>def <span class="ident">KD_filter</span></span>(<span>Y:Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Kd-tree filtering algorithm from Chen2012</p>
<h2 id="args">Args</h2>
<p>Y (PointList)</p>
<h2 id="returns">Returns</h2>
<p>Yn (PointList) set of nondominated points
Returns: PointList with all nondominated points removed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def KD_filter(Y: PointList):
    &#34;&#34;&#34; Kd-tree filtering algorithm from Chen2012

    Args:
        Y (PointList)

    Returns:
        Yn (PointList) set of nondominated points 

    Returns: PointList with all nondominated points removed

    &#34;&#34;&#34;
    Y = lex_sort(Y) # sort input list
    R = []
    for i, y in enumerate(Y):
        if i == 0:
            r = KD_Node(Y[0], 0)
            r.UB = r.y
            r.LB = r.y
            k = 0
            R.append(y)
            continue

        if not KD_tree.dominates_point(r, y):
            # print(f&#34;{y=}&#34;)
            KD_tree.insert(r,0, y)
            R.append(y)
            k += 1

    r = None
    Yn = []
    for i, y in enumerate(reversed(R)):
        if i == 0:
            r = KD_Node(y, 0)
            r.UB = r.y
            r.LB = r.y
            Yn.append(y)
            continue
        
        if not KD_tree.dominates_point(r, y):
            KD_tree.insert(r,0, y)
            Yn.append(y)

    Yn = PointList(Yn)

    return Yn</code></pre>
</details>
</dd>
<dt id="methods.MS_doubling_filter"><code class="name flex">
<span>def <span class="ident">MS_doubling_filter</span></span>(<span>Y_list=list[classes.PointList], MS_filter_alg=&lt;function MS_sequential_filter&gt;) â€‘>Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a></span>
</code></dt>
<dd>
<div class="desc"><p>input: list of PointList
output: nondominated points of Minkowski sum of sets Y_list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MS_doubling_filter(Y_list = list[PointList], MS_filter_alg = MS_sequential_filter) -&gt; PointList:
    &#34;&#34;&#34;
    input: list of PointList
    output: nondominated points of Minkowski sum of sets Y_list
    &#34;&#34;&#34;

    s = len(Y_list)
    S = Y_list
    while s &gt; 1:
        S_new = []
        for k in range(math.floor(s/2)):
            S_new.append(MS_filter_alg((S[2*k], S[2*k+1])))
        if s % 2 != 0:
            S_new.append(S[-1])
        s = math.ceil(s/2)
        S = S_new
    return S[0]</code></pre>
</details>
</dd>
<dt id="methods.MS_naive_filter"><code class="name flex">
<span>def <span class="ident">MS_naive_filter</span></span>(<span>Y_list=list[classes.PointList]) â€‘>Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a></span>
</code></dt>
<dd>
<div class="desc"><p>input: list of PointList
output: nondominated points of Minkowski sum of sets Y_list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MS_naive_filter(Y_list = list[PointList]) -&gt; PointList:
    &#34;&#34;&#34;
    input: list of PointList
    output: nondominated points of Minkowski sum of sets Y_list
    &#34;&#34;&#34;
    Y = MS_sum(Y_list)
    Yn = N(Y)

    return PointList(Yn)</code></pre>
</details>
</dd>
<dt id="methods.MS_sequential_filter"><code class="name flex">
<span>def <span class="ident">MS_sequential_filter</span></span>(<span>Y_list=list[classes.PointList], N=&lt;function N&gt;) â€‘>Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a></span>
</code></dt>
<dd>
<div class="desc"><p>input: list of PointList
output: nondominated points of Minkowski sum of sets Y_list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MS_sequential_filter(Y_list = list[PointList], N = N) -&gt; PointList:
    &#34;&#34;&#34;
    input: list of PointList
    output: nondominated points of Minkowski sum of sets Y_list
    &#34;&#34;&#34;
    Y_ms = N(Y_list[0])

    for s in range(1, len(Y_list)):
        # print(f&#34;{s=}&#34;)
        # print(f&#34;{len(Y_ms)=}&#34;)
        # Y_ms = N(Y_ms + N(Y_list[s]))
        Y_ms = ND_pointsSum2_wrapper(Y_ms, N(Y_list[s]))
        Y_ms = Y_ms.removed_duplicates()
        # assert Y_ms == N(Y_ms), f&#34;{len(Y_ms),len(N(Y_ms)),len(Y_ms.removed_duplicates())=}&#34;
        if Y_ms is None:
            return None

    return PointList(Y_ms)</code></pre>
</details>
</dd>
<dt id="methods.MS_sum"><code class="name flex">
<span>def <span class="ident">MS_sum</span></span>(<span>Y_list=list[classes.PointList], operator='+') â€‘>Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a></span>
</code></dt>
<dd>
<div class="desc"><p>input: list of PointList
output: Minkowski sum of sets</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MS_sum(Y_list = list[PointList], operator = &#34;+&#34;) -&gt; PointList:
    &#34;&#34;&#34;
    input: list of PointList
    output: Minkowski sum of sets
    &#34;&#34;&#34;
    assert operator in (&#34;+&#34;,&#34;-&#34;,&#34;*&#34;)

    Y_ms = Y_list[0]
    for s in range(1, len(Y_list)):
        Y_ms_new = []
        Y_s = Y_list[s]
        for y_ms in Y_ms:
            for y_s in Y_s:
                if operator == &#34;+&#34;:
                    Y_ms_new.append(y_ms+y_s)
                if operator == &#34;-&#34;:
                    Y_ms_new.append(y_ms-y_s)
                if operator == &#34;*&#34;:
                    Y_ms_new.append(y_ms*y_s)
        Y_ms = Y_ms_new

    return PointList(Y_ms)</code></pre>
</details>
</dd>
<dt id="methods.N"><code class="name flex">
<span>def <span class="ident">N</span></span>(<span>Y=classes.PointList, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>'best' implemented nondominance filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def N(Y = PointList, **kwargs):
    &#34;&#34;&#34; &#39;best&#39; implemented nondominance filter &#34;&#34;&#34;
    if Y[0].dim &lt;= 2:
        return unidirectional_filter(Y, *kwargs)
    else:
        return nondomDC_wrapper(Y)


    # elif len(Y) &lt; 1024*2:
        # return KD_filter(Y)
    # else:
        # return nondomDC_wrapper(Y)
        # return naive_filter(Y, MCtF = True)
        # return two_phase_filter(Y)</code></pre>
</details>
</dd>
<dt id="methods.ND_pointsSum2_wrapper"><code class="name flex">
<span>def <span class="ident">ND_pointsSum2_wrapper</span></span>(<span>A:Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a>, B:Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a>) â€‘>Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ND_pointsSum2_wrapper(A : PointList, B : PointList) -&gt; PointList:
    # A python wrapper for the c implementation of ND_pointsSum2 [Bruno Lang]
    call_id = str(uuid.uuid4())
    # out_file = fr&#34;/Users/au618299/Desktop/cythonTest/nondom/temp/pointsIn-{call_id}&#34; # c script directory
    out_fileA = fr&#34;temp/pointsInA-{call_id}&#34; # c script directory
    out_fileB = fr&#34;temp/pointsInB-{call_id}&#34; # c script directory
    A.save_raw(out_fileA)
    B.save_raw(out_fileB)
    try:
        call_c_ND_pointsSum2(call_id)
    finally:
        os.remove(out_fileA)
        os.remove(out_fileB)


    in_file = filepath = fr&#34;temp/pointsOut-{call_id}&#34; # c script directory
    try:
        Yn = PointList.from_raw(in_file)
    except FileNotFoundError:
        return None

    if True: # clear temp folder
        os.remove(in_file)
    return Yn.removed_duplicates()</code></pre>
</details>
</dd>
<dt id="methods.U_dominates_L"><code class="name flex">
<span>def <span class="ident">U_dominates_L</span></span>(<span>U:Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a>, L:Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the lower bound L is dominated by the upper bound U
input :
U : list of non-dominated points as tuples
L : list of supported points which make up the lower bound set</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def U_dominates_L(U: PointList, L:PointList):
    &#39;&#39;&#39;
    Checks if the lower bound L is dominated by the upper bound U
    input :
        U : list of non-dominated points as tuples
        L : list of supported points which make up the lower bound set
    &#39;&#39;&#39;
    assert all((L.dim == U.dim, L.dim == 2))
    # y = sorted(set(L)) # sort non-dominated points

    
    if L.is_complete: # Assume Yn = Ln, ie LB not defined by the convex hull
        return N(U) &lt; N(L)


    L = lex_sort(N(L))
    local_nadir_points = induced_UB(U)

    if len(L) == 1:
        return U.dominates_point(L[0])
    
    # Check that all extreme points of L are dominated
    for l in L:
        for u in U:
            if u &lt; l:
                break
        else: # finally, if loop terminates normally
            # print(f&#34;The LB point {l=} is not dominated by any point of U&#34;)
            return False

    # Check that all line segments of L are dominated
    for i in range(len(set(L)) - 1):
        # define linear function (line between l[i] and l[i+1])
        lin_fct = lambda x : L[i][1] + (L[i+1][1]-L[i][1])/(L[i+1][0]-L[i][0])*(x-L[i][0])
        for n in local_nadir_points:
            if L[i][0] &lt;= n[0] and n[0] &lt;= L[i+1][0]:
                if n[1] &gt; lin_fct(n[0]):
                    # print(f&#34;line between {L[i],L[i+1]} is not dominated by nadir-point {n}&#34;)
                    return False
                if math.isclose(n[1], lin_fct(n[0])):
                    return False
    # if loop ends, the node is not dominated by the upper bound set
    return True</code></pre>
</details>
</dd>
<dt id="methods.basic_filter"><code class="name flex">
<span>def <span class="ident">basic_filter</span></span>(<span>Y:Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>input: PointList
output: PointList with all nondominated points removed</p>
<h2 id="alg">Alg</h2>
<p>For each point y, check if any other point y2 dominates y: if no, add y to Yn</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def basic_filter(Y:PointList):
    &#34;&#34;&#34;
    input: PointList
    output: PointList with all nondominated points removed

    ALG:
        For each point y, check if any other point y2 dominates y: if no, add y to Yn
    &#34;&#34;&#34;
    Yn = []

    for y in Y:
        for y2 in Y:
            if y2 &lt; y:
               break 
        else:
            Yn.append(y)

    return(PointList(Yn))</code></pre>
</details>
</dd>
<dt id="methods.call_c_ND_pointsSum2"><code class="name flex">
<span>def <span class="ident">call_c_ND_pointsSum2</span></span>(<span>call_id:Â str, max_time=None, max_gb=None, logger=None, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_c_ND_pointsSum2(call_id:str, max_time=None,max_gb=None, logger=None, verbose = False):
    assert &#39;ND_pointsSum2&#39; in os.listdir()

    # print(f&#34;calling subprocess &#34;)
    if max_gb:
        if verbose:
            p = subprocess.Popen([&#39;./ND_pointsSum2&#39;,call_id,str(max_gb)])
        else:
            p = subprocess.Popen([&#39;./ND_pointsSum2&#39;,call_id,str(max_gb)], stdout=subprocess.DEVNULL)
    else:
        if verbose:
            p = subprocess.Popen([&#39;./ND_pointsSum2&#39;,call_id])
        else:
            p = subprocess.Popen([&#39;./ND_pointsSum2&#39;,call_id], stdout=subprocess.DEVNULL)

    
    try:
        if max_time:
            p.wait(timeout=max_time*60)
        else:
            p.wait()
    except subprocess.TimeoutExpired:
        print(f&#34;Process timed out after {max_time} seconds&#34;)
        p.kill()
        print(&#34;Process killed due to timeout&#34;)
        if logger:
            logger.warning(&#34;Process timed out after {max_time} seconds {call_id=}&#34;)
            logger.info(f&#34;{p.returncode=}&#34;)
        print(f&#34;{p.returncode=}&#34;)
    # print(f&#34;subprocess complete &#34;)</code></pre>
</details>
</dd>
<dt id="methods.call_c_nondomDC"><code class="name flex">
<span>def <span class="ident">call_c_nondomDC</span></span>(<span>call_id:Â str, max_time=None, logger=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_c_nondomDC(call_id:str, max_time=None, logger=None):
    # current_d = os.getcwd()
    # move to c folder and execute
    # os.chdir(&#39;/Users/au618299/Desktop/cythonTest/nondom/&#39;)
    # subprocess.call([&#39;./nondom&#39;,call_id])
    # return to initial directory
    # os.chdir(current_d)
    # subprocess.call([&#39;/Users/au618299/Desktop/cythonTest/nondom/./nondom&#39;,call_id])
    assert &#39;nondom&#39; in os.listdir()
    # subprocess.call([&#39;./nondom&#39;,call_id])
    p = subprocess.Popen([&#39;./nondom&#39;,call_id])

    try:
        if max_time:
            p.wait(timeout=max_time*60)
        else:
            p.wait()
    except subprocess.TimeoutExpired:
        print(f&#34;Process timed out after {max_time} seconds&#34;)
        p.kill()
        print(&#34;Process killed due to timeout&#34;)
        if logger:
            logger.warning(&#34;Process timed out after {max_time} seconds {call_id=}&#34;)</code></pre>
</details>
</dd>
<dt id="methods.find_generator_U"><code class="name flex">
<span>def <span class="ident">find_generator_U</span></span>(<span>Y1:Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a>, Y2:Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a>) â€‘>Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a></span>
</code></dt>
<dd>
<div class="desc"><p>input: two sets Y1, Y2, where Y1 contains (global) lex min solutions.
output: A set of generator upper bound points Uc as PointList</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_generator_U(Y1:PointList, Y2:PointList) -&gt; PointList:
    &#34;&#34;&#34;
    input: two sets Y1, Y2, where Y1 contains (global) lex min solutions.
    output: A set of generator upper bound points Uc as PointList
    &#34;&#34;&#34;

    def get_i(points: PointList, q: Point):
        &#34;&#34;&#34;
        intervals: a PointList y1_1 &lt; y2_1 &lt; y3_1 ... 
        q: a Point
        returns the id i of PointList where yi_1 == q_1
        &#34;&#34;&#34;
        if points[0][0] == q[0]:
            return 0
        if points[-1][0] &lt;= q[0]:
            return -1 

        # assert that Q is sorted (consequence of Y2 sorted)
        for i, y in enumerate(points):
            if points[i][0] &lt;= q[0] and q[0] &lt; points[i+1][0]:
                return i

    Y1 = N(Y1)
    Y2 = N(Y2)

    Y = N(Y1+Y2)

    y_ul = Y1[0]
    y_lr = Y1[-1]

    u_current = y_ul
    Uc = [u_current]
    Q = PointList((u_current,)) + Y2

    while u_current != y_lr:
        #assert Q == PointList((u_current,)) + Y2
        # determine right movement
        Q_bar = [q for q in Q if Y[get_i(Y,q)][1] == q[1]]
        l1 = max([Y[get_i(Y,q)+1][0]-q[0] for q in Q_bar])

        # determine down movement
        Q = Point((l1,0)) + Q
        u_current = u_current + Point((l1, 0))
        l2 = min([q[1] - Y[get_i(Y,q)][1] for q in Q])

        # Update Q, u_current and Uc
        Q = Point((0,-l2)) + Q
        u_current = u_current + Point((0, -l2))
        Uc.append(u_current)

    return PointList(Uc)</code></pre>
</details>
</dd>
<dt id="methods.induced_UB"><code class="name flex">
<span>def <span class="ident">induced_UB</span></span>(<span>Y:Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a>, line=False, assumption='consecutive')</span>
</code></dt>
<dd>
<div class="desc"><p>Induced upper bound set from pointlist Y, points are assumed to be consecutive in Yn</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def induced_UB(Y: PointList, line=False, assumption = &#34;consecutive&#34;):
    &#34;&#34;&#34; Induced upper bound set from pointlist Y, points are assumed to be consecutive in Yn&#34;&#34;&#34;
    # arg assumption in [consecutive, supported, nonconsecutive]
    assert assumption in [&#34;consecutive&#34;, &#34;supported&#34;, &#34;nonconsecutive&#34;,&#34;localNadir&#34;]

    Y = N(Y)
    Y = lex_sort(Y)
    U = []
    seen = set() # for spotting duplicates
    if line:
        U.append(Y[0])
        for i in range(len(Y)-1):
                if assumption == &#34;consecutive&#34;:
                    u = Point((Y[i+1][0], Y[i][1]))
                elif assumption in {&#34;nonconsecutive&#34;, &#34;localNadir&#34;}:
                    u = Point((Y[i][0], Y[i+1][1]))
                if assumption != &#34;supported&#34;:
                    U.append(u)
                U.append(Y[i+1])
    else:
        for i in range(len(Y)-1):
            if Y[i+1] not in seen: # ignore duplicates
                seen.add(Y[i+1])
                u = Point((Y[i+1][0], Y[i][1]))
                U.append(u)
    if assumption == &#39;localNadir&#39;:
        U = PointList([Y[0]] + U + [Y[-1]])
        assert U.dim == 2
    else:
        U = PointList(U)
    return U</code></pre>
</details>
</dd>
<dt id="methods.lex_filter"><code class="name flex">
<span>def <span class="ident">lex_filter</span></span>(<span>Y:Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>function for filtering out dominated points using linked lists for p = 2$</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lex_filter(Y: PointList):
    &#34;&#34;&#34;function for filtering out dominated points using linked lists for p = 2$&#34;&#34;&#34;
    assert Y.dim &lt;= 2, &#34;dim p &gt; 2 NOT IMPLEMENTED&#34;
 
    llist = LinkedList()
    llist.add_first(Node(Y[0]))
    llist.head.prev = None

    for y_current in Y[1:]:
        for N in llist:
            if y_current.val[0] &gt;= N.data.val[0]:
                if y_current.val[1] &gt;= N.data.val[1]:
                    break
                else:
                    continue
            # traverse linked list until y lex dominated the node N
            if y_current.lex_le(N.data):
                new_node = Node(y_current)
                # add before N
                llist.add_before(N.data, new_node)

                # remove N.data and all dominated children
                first_nondom = N
                while first_nondom != None and y_current &lt; first_nondom.data:
                    first_nondom = first_nondom.next
                    # print(f&#34;removing {first_nondom}&#34;)
                new_node.next = first_nondom
                break
           #  elif N.data &lt; y_current:
           #      break
            prev = N
        else:
            if N.next == None:
                if not N.data &lt; y_current:
                    new_node = Node(y_current)
                    N.next = new_node
    return PointList((N.data for N in llist.__iter__()))</code></pre>
</details>
</dd>
<dt id="methods.lex_sort"><code class="name flex">
<span>def <span class="ident">lex_sort</span></span>(<span>Y:Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>input: PointList
output: lexicographically sorted PointList Y</p>
<p>source <a href="https://stackoverflow.com/questions/38277143/sort-2d-numpy-array-lexicographically">https://stackoverflow.com/questions/38277143/sort-2d-numpy-array-lexicographically</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lex_sort(Y: PointList):
    &#34;&#34;&#34;
    input: PointList
    output: lexicographically sorted PointList Y

    source https://stackoverflow.com/questions/38277143/sort-2d-numpy-array-lexicographically
    &#34;&#34;&#34;
    Y.points = sorted(Y.points, key=itemgetter(*range(Y.dim)))

    for i in range(len(Y.points)-1): # simple but not exhaustive correctness check
        assert not Y[i] &gt; Y[i+1], f&#34;{Y[i]=},{Y[i+1]=} &#34;

    return PointList(Y.points)</code></pre>
</details>
</dd>
<dt id="methods.lex_sort_linked"><code class="name flex">
<span>def <span class="ident">lex_sort_linked</span></span>(<span>Y:Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>function for sorting p = 2$</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lex_sort_linked(Y: PointList):
    &#34;&#34;&#34;function for sorting p = 2$&#34;&#34;&#34;
    assert Y.dim &lt;= 2, &#34;dim p &gt; 2 NOT IMPLEMENTED&#34;
 
    llist = LinkedList()
    llist.add_first(Node(Y[0]))
    llist.head.prev = None

    for y_current in Y[1:]:
        for N in llist:
            if y_current.val[0] &gt;= N.data.val[0]:
                continue
            # traverse linked list until y lex dominated the node N
            if y_current.lex_le(N.data):
                new_node = Node(y_current)
                # add before N
                llist.add_before(N.data, new_node)

                # remove N.data and all dominated children
                first_nondom = N
                # while first_nondom != None and y_current &lt; first_nondom.data:
                    # first_nondom = first_nondom.next
                    # print(f&#34;removing {first_nondom}&#34;)
                new_node.next = first_nondom
                break
           #  elif N.data &lt; y_current:
           #      break
            prev = N
        else:
            if N.next == None:
                new_node = Node(y_current)
                N.next = new_node
    return PointList((N.data for N in llist.__iter__()))</code></pre>
</details>
</dd>
<dt id="methods.naive_filter"><code class="name flex">
<span>def <span class="ident">naive_filter</span></span>(<span>Y:Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a>, MCtF=False) â€‘>Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a></span>
</code></dt>
<dd>
<div class="desc"><p>input: PointList
output: PointList with all nondominated points removed</p>
<h2 id="alg">Alg</h2>
<p>For each point y, check if any other point y2 dominates y: if no, add y to Yn</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def naive_filter(Y:PointList, MCtF = False) -&gt; PointList:
    &#34;&#34;&#34;
    input: PointList
    output: PointList with all nondominated points removed

    ALG:
        For each point y, check if any other point y2 dominates y: if no, add y to Yn
    &#34;&#34;&#34;
    Yn = deque()

    for i, y in enumerate(Y):
        dominated_indices_y = set()
        for j, y2 in enumerate(Yn):
            if y2 &lt;= y:
                break # discard y
            if y2 &gt; y:
                dominated_indices_y.add(j) # record dominance
        else:
            # remove dominated points
            Yn = deque((y_ for j_, y_ in enumerate(Yn) if j_ not in dominated_indices_y))
            # add nondominated candidate
            if MCtF and dominated_indices_y:
                Yn.appendleft(y)
            else:
                Yn.append(y)

    # Y.points = Yn
    return(PointList(Yn))</code></pre>
</details>
</dd>
<dt id="methods.nondomDC_wrapper"><code class="name flex">
<span>def <span class="ident">nondomDC_wrapper</span></span>(<span>Y:Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nondomDC_wrapper(Y : PointList):
    # A python wrapper for the c implementation of NonDomDC [Bruno Lang]
    call_id = str(uuid.uuid4())
    # out_file = fr&#34;/Users/au618299/Desktop/cythonTest/nondom/temp/pointsIn-{call_id}&#34; # c script directory
    out_file = fr&#34;temp/pointsIn-{call_id}&#34; # c script directory
    Y.save_raw(out_file)
    assert os.path.exists(out_file), f&#34;{out_file=}&#34;

    try:
        out_str = call_c_nondomDC(call_id)
    finally:
        os.remove(out_file)
    # in_file = filepath = fr&#34;/Users/au618299/Desktop/cythonTest/nondom/temp/pointsOut-{call_id}&#34; # c script directory
    in_file = filepath = fr&#34;temp/pointsOut-{call_id}&#34; # c script directory
    assert os.path.exists(in_file), f&#34;{in_file,out_str=}&#34;
    Yn = PointList.from_raw(in_file)
    # print(f&#34;{in_file=}&#34;)
    try:
        Yn = PointList.from_raw(in_file)
    except FileNotFoundError:
        print(f&#34;File not found&#34;)
        print(f&#34;{in_file=}&#34;)
        return None

    if True: # clear temp folder
        # os.remove(out_file)
        os.remove(in_file)
    return Yn.removed_duplicates()</code></pre>
</details>
</dd>
<dt id="methods.two_phase_filter"><code class="name flex">
<span>def <span class="ident">two_phase_filter</span></span>(<span>Y:Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a>) â€‘>Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a></span>
</code></dt>
<dd>
<div class="desc"><p>Two phase filter from Chen2012 for filtering a list of points</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>Y</code></strong> :&ensp;<code>PointList</code></dt>
<dd>Yn (PointList) set of nondominated points </dd>
</dl>
<p>Returns: PointList with all nondominated points removed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def two_phase_filter(Y: PointList) -&gt; PointList:
    &#34;&#34;&#34; Two phase filter from Chen2012 for filtering a list of points

    Args:
        Y (PointList): Yn (PointList) set of nondominated points 

    Returns: PointList with all nondominated points removed
    &#34;&#34;&#34;
    
    Y = lex_sort(Y)
    
    Yn = PointList(())
    Yn.dim = Y.dim
    Yn.points = list(Yn.points)
    # phase 1
    for i, y in enumerate(Y):
        if not Yn.weakly_dominates_point(y):
            Yn.points.append(y)
    # print(f&#34;Phase 1 result: {Yn=}&#34;)
    # phase 2
    Yn_new = PointList()
    Yn_new.dim = Yn.dim
    Yn_new.points = list(Yn_new.points)
    for i in range(len(Yn)):
        y = Yn[-i + 1]
        if not Yn_new.weakly_dominates_point(y):
            Yn_new.points.append(y)
    return Yn_new       </code></pre>
</details>
</dd>
<dt id="methods.unidirectional_filter"><code class="name flex">
<span>def <span class="ident">unidirectional_filter</span></span>(<span>Y:Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a>, duplicates_allowed=False) â€‘>Â <a title="classes.PointList" href="classes.html#classes.PointList">PointList</a></span>
</code></dt>
<dd>
<div class="desc"><p>input: PointList, bool - allowed_duplicates
output: PointList with all nondominated points removed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unidirectional_filter(Y: PointList, duplicates_allowed = False) -&gt; PointList:
    &#34;&#34;&#34;
    input: PointList, bool - allowed_duplicates
    output: PointList with all nondominated points removed
    &#34;&#34;&#34;


    Y = lex_sort(Y)

    # p = 2
    assert Y[0].val.shape[0] &lt;= 2, &#34;dim p &gt; 2 NOT IMPLEMENTED&#34;
    Yn = []
    
    if duplicates_allowed:
        for y in Y:
            if Yn == [] or not Yn[-1] &lt; y:
                Yn.append(y)
                # assert not PointList(Yn).dominates_point(y), f&#34;{Yn=}, {y=}&#34;
    
    else: # if duplicates not allowed
        for y in Y:
            if Yn == [] or not Yn[-1] &lt;= y:
                Yn.append(y)
    return(PointList(Yn))

    # p &gt; 2 NOT IMPLEMENTED</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="methods.KD_filter" href="#methods.KD_filter">KD_filter</a></code></li>
<li><code><a title="methods.MS_doubling_filter" href="#methods.MS_doubling_filter">MS_doubling_filter</a></code></li>
<li><code><a title="methods.MS_naive_filter" href="#methods.MS_naive_filter">MS_naive_filter</a></code></li>
<li><code><a title="methods.MS_sequential_filter" href="#methods.MS_sequential_filter">MS_sequential_filter</a></code></li>
<li><code><a title="methods.MS_sum" href="#methods.MS_sum">MS_sum</a></code></li>
<li><code><a title="methods.N" href="#methods.N">N</a></code></li>
<li><code><a title="methods.ND_pointsSum2_wrapper" href="#methods.ND_pointsSum2_wrapper">ND_pointsSum2_wrapper</a></code></li>
<li><code><a title="methods.U_dominates_L" href="#methods.U_dominates_L">U_dominates_L</a></code></li>
<li><code><a title="methods.basic_filter" href="#methods.basic_filter">basic_filter</a></code></li>
<li><code><a title="methods.call_c_ND_pointsSum2" href="#methods.call_c_ND_pointsSum2">call_c_ND_pointsSum2</a></code></li>
<li><code><a title="methods.call_c_nondomDC" href="#methods.call_c_nondomDC">call_c_nondomDC</a></code></li>
<li><code><a title="methods.find_generator_U" href="#methods.find_generator_U">find_generator_U</a></code></li>
<li><code><a title="methods.induced_UB" href="#methods.induced_UB">induced_UB</a></code></li>
<li><code><a title="methods.lex_filter" href="#methods.lex_filter">lex_filter</a></code></li>
<li><code><a title="methods.lex_sort" href="#methods.lex_sort">lex_sort</a></code></li>
<li><code><a title="methods.lex_sort_linked" href="#methods.lex_sort_linked">lex_sort_linked</a></code></li>
<li><code><a title="methods.naive_filter" href="#methods.naive_filter">naive_filter</a></code></li>
<li><code><a title="methods.nondomDC_wrapper" href="#methods.nondomDC_wrapper">nondomDC_wrapper</a></code></li>
<li><code><a title="methods.two_phase_filter" href="#methods.two_phase_filter">two_phase_filter</a></code></li>
<li><code><a title="methods.unidirectional_filter" href="#methods.unidirectional_filter">unidirectional_filter</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>